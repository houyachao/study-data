轻量级锁（自旋锁，需要写一个while 循环，占用CPU 资源） 效率 不一定高于重量级锁（需要存放到队列里，不占用资源）。

synchronized 



1个线程 偏向锁（偏向锁不是锁，只是记录第一个线程的id的标识，下次如果还是这个线程来的时候，就直接执行就可以了） ，两个或多个线程来抢锁的时候需要升级 自旋锁，偏向锁需要升级为自旋锁，因为需要抢占锁了。

自旋锁 转圈 如果超过10次的话，需要升级为 重量级锁，进入队列中。（轻量级锁是在用户态解决锁的问题，而重量级锁是在内核态解决锁的问题（也即操作系统层面解决））。

加锁代码执行时间比较短，线程数比较少，可以用自旋锁。

执行时间比较长（加锁代码），线程数比较多，用系统锁。



类库 jol ，    org.openjdk.jol  





单机环境下： Disruptor  消息中间件 效率最高。

线程的概念：一个程序里，不同的执行路线。就叫做一个线程。

启动线程的三种方式：Thread，Runnable，线程池 Executors.newCachedThread.

线程中常用方法：

​	1、yield() ， 当现在执行的时候，让出当前执行的线程的cpu，然后回到等待队列中，就绪状态。

​	2、join（），当有两个线程t1，t2，在t1线程中调用t2.join。 让T2 线程加入到t1线程中，让t1 线程去执行t2线程任务， t2线程执行完后再执行t1剩下的程序。



synchronized  是可重入锁。假如一个父类，一个子类继承了父类，在父类有一个方法m()，子类也有一个m()，这两个方法都是synchronized 的，在子类中super()，调用父类的方法，如果不是可重入锁， 就违反继承了，还有就是参数死锁。

程序在执行过程中，如果出现异常，默认情况下锁会被释放。所以在并发处理的过程中，有异常要多加小心，不然可能会发生不一致的情况。



Volatile ： 保证线程可见性（MESI ，缓存一致性协议	），禁止指令重排序。

synchronized 单例双重效验机制，需要加Volatile 吗？  需要加，因为在new 这个对象的时候，会发生指令重排，在new 的过程中，在jvm 中，会先申请一个空间并初始化为0，然后在赋值，最后指向栈。  有可能在初始化一半的时候，就指向了栈。

synchronized 只保证 原子性。

Lock lock = new ReentrantLock();  lock.newCondition()； 意思为new 了一个等待队列。











































