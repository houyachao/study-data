# 一、Zookeeper

## 1、Zookeeper 是什么？

​	官方文档：<https://zookeeper.apache.org/doc/r3.3.2/zookeeperOver.html>

​	Zookeeper 是一个开源的分布式协调服务，由雅虎创建，是Google Ghubby 的开源实现。分布式应用程序可以基于 Zookeeper 实现诸如数据发布/订阅，负载均衡，命名服务，分布式协调/通知，集群管理，Master 选举，配置维护，名字服务，分布式同步，分布式锁和分布式队列等功能。ZooKeeper是用于分布式应用程序的分布式，开放源代码协调服务。它公开了一组简单的原语，分布式应用程序可以基于这些原语来实现用于同步，配置维护以及组和命名的更高级别的服务。它的设计易于编程，并使用了按照文件系统熟悉的目录树结构样式设置的数据模型。**ZooKeeper 将数据保存在内存中，**这也就保证了 高吞吐量和低延迟（但是内存限制了能够存储的容量不太大，此限制也是保持 Znode 中存储的数据量较小的进一步原因）。

**原语： **操作系统或计算机网络用语范畴。它是由若干条指令组成的，用于完成一定功能的一个过程。具有不可分割性，即原语的执行必须是连续的，在执行过程中不允许被中断。

## 2、Zookeeper 保证

### ① 顺序一致性

​	来自客户端的更新将按照发送的顺序应用。因为当写请求到其他节点，其他节点需要往leader节点写，然后再同步到follower节点。

### ②原子性

​	更新成功或失败，没有部分结构。

### ③单个系统映像

​	无论客户端连接到那个服务器，客户端都将看到相同的服务视图，

### ④可靠性

​	应用更新后，此更新将一直持续到客户端覆盖更新为止。

### ⑤及时性

​	确保系统的客户视图在特定时间范围内是最新的。

## 3、Zookeeper 基本概念

### ① 集群角色

​	**Leader、Follower、Observe、**

一个Zookeeper 集群同一时刻只会有一个Leader、其他都是Follower 或 Observer。

Zookeeper 配置很简单，每个节点的配置文件（zoo.cfg）都是一样的，**只有myid 文件不一样。myid 的值必须是zoo.cfg 中 server.{数值} 的 {数值}部分。**

zoo.cfg配置文件示例 

![1.Zookeeper 6](C:\Users\Administrator\Desktop\笔记\Zookeeper\1.Zookeeper 6.jpg)

在装有 Zookeeper 的机器的终端执行 Zookeeper-server status 可以看当前节点的Zookeeper 是什么角色。

Zookeeper 默认只有 Leader 和Follower 两种角色，没有Observer 角色，为了使用Observer 模式，在任何想变成Observer 的节点配置文件中加入 :peerType = observer 并在所有server 的配置文件中，配置成observer 模式的server 的哪行配置追加 :observer。

```xml
解读zoo.cfg 文件中参数含义

1）tickTime：通信心跳数，Zookeeper服务器心跳时间，单位毫秒

Zookeeper使用的基本时间，服务器之间或客户端与服务器之间维持心跳的时间间隔，也就是每个tickTime时间就会发送一个心跳，时间单位为毫秒。

它用于心跳机制，并且设置最小的session超时时间为两倍心跳时间。(session的最小超时时间是2*tickTime)

2）initLimit：LF初始通信时限

集群中的follower跟随者服务器(F)与leader领导者服务器(L)之间初始连接时能容忍的最多心跳数（tickTime的数量），用它来限定集群中的Zookeeper服务器连接到Leader的时限。

投票选举新leader的初始化时间

Follower在启动过程中，会从Leader同步所有最新数据，然后确定自己能够对外服务的起始状态。

Leader允许F在initLimit时间内完成这个工作。

3）syncLimit：LF同步通信时限

集群中Leader与Follower之间的最大响应时间单位，假如响应超过syncLimit * tickTime，

Leader认为Follwer死掉，从服务器列表中删除Follwer。

在运行过程中，Leader负责与ZK集群中所有机器进行通信，例如通过一些心跳检测机制，来检测机器的存活状态。

如果L发出心跳包在syncLimit之后，还没有从F那收到响应，那么就认为这个F已经不在线了。

4）dataDir：数据文件目录+数据持久化路径保存内存数据库快照信息的位置，如果没有其他说明，更新的事务日志也保存到数据库。

5）clientPort：客户端连接端口

监听客户端连接的端口
```

### ② 节点读写服务分工

   1.ZooKeeper 集群的所有机器通过一个 Leader 选举过程来选定一台被称为『Leader』
   的机器，Leader服务器为客户端提供读和写服务。

   2.Follower 和 Observer 都能提供读服务，不能提供写服务。两者唯一的区别在于，
   Observer机器不参与 Leader 选举过程，也不参与写操作的『过半写成功』策略，因
   此 Observer 可以在不影响写性能的情况下提升集群的读性能。

### ③ Session

​	Session 是指客户端会话，在讲解客户端会话之前，我们先来了解下客户端连接。在
  ZooKeeper 中，一个客户端连接是指客户端和 ZooKeeper 服务器之间的TCP长连接。

​       ZooKeeper 对外的服务端口默认是2181，客户端启动时，首先会与服务器建立一个TCP
  连接，从第一次连接建立开始，客户端会话的生命周期也开始了，通过这个连接，客户端能够通
  过心跳检测和服务器保持有效的会话，也能够向 ZooKeeper 服务器发送请求并接受响应，同
  时还能通过该连接接收来自服务器的 Watch 事件通知。

​      Session 的 SessionTimeout 值用来设置一个客户端会话的超时时间。当由于服务器
  压力太大、网络故障或是客户端主动断开连接等各种原因导致客户端连接断开时，只要在 
  SessionTimeout 规定的时间内能够重新连接上集群中任意一台服务器，那么之前创建的会话
  仍然有效。

### ④数据节点

zookeeper的结构其实就是一个树形结构，leader就相当于其中的根结点，其它节点就相当于
 follow节点，每个节点都保留自己的内容。

​     zookeeper的节点分两类：持久节点和临时节点
     - 持久节点：
          谓持久节点是指一旦这个 树形结构上被创建了，除非主动进行对树节点的移除操
          ​        作，否则这个 节点将一直保存在 ZooKeeper 上。
     - 临时节点：
          时节点的生命周期跟客户端会话绑定，一旦客户端会话失效，那么这个客户端创
          ​        建的所有临时节点都会被移除。

### ⑤状态信息

​    每个 节点除了存储数据内容之外，还存储了 节点本身的一些状态信息。用 get 命令可以
同时获得某个 节点的内容和状态信息
​    在 ZooKeeper 中，version 属性是用来实现乐观锁机制中的『写入校验』的（保证分布
式数据原子性操作）。

### ⑥ 事务操作

​    在ZooKeeper中，能改变ZooKeeper服务器状态的操作称为事务操作。一般包括数据节点
创建与删除、数据内容更新和客户端会话创建与失效等操作。对应每一个事务请求，ZooKeeper
都会为其分配一个全局唯一的事务ID，用 ZXID 表示，通常是一个64位的数字。每一个 ZXID
对应一次更新操作，从这些 ZXID 中可以间接地识别出 ZooKeeper 处理这些事务操作请求的
全局顺序。

### ⑦ Watcher（事件监听器）

​    是 ZooKeeper 中一个很重要的特性。ZooKeeper允许用户在指定节点上注册一些 Watcher，
并且在一些特定事件触发的时候，ZooKeeper 服务端会将事件通知到感兴趣的客户端上去。该
机制是 ZooKeeper 实现分布式协调服务的重要特性。

### ⑧ 选举机制

1、半数机制：集群中半数以上机器存活，集群可用。所以zookeeper适合装在**奇数**台机器上。

2、Zookeeper虽然在配置文件中并没有指定master和slave。但是，zookeeper工作时，是有一个节点为leader，其他则为follower，Leader是通过内部的选举机制临时产生的

3、以一个简单的例子来说明整个选举的过程。

假设有五台服务器组成的zookeeper集群，它们的id从1-5，同时它们都是最新启动的，也就是没有历史数据，在存放数据量这一点上，都是一样的。假设这些服务器依序启动，来看看会发生什么。

![1.Zookeeper 7](C:\Users\Administrator\Desktop\笔记\Zookeeper\1.Zookeeper 7.png)

（1）服务器1启动，此时只有它一台服务器启动了，它发出去的报没有任何响应，所以它的选举状态一直是LOOKING状态。

（2）服务器2启动，它与最开始启动的服务器1进行通信，互相交换自己的选举结果，由于两者都没有历史数据，所以id值（myid）较大的服务器2胜出，但是由于没有达到超过半数以上的服务器都同意选举它(这个例子中的半数以上是3)，所以服务器1、2还是继续保持LOOKING状态。

（3）服务器3启动，根据前面的理论分析，服务器3成为服务器1、2、3中的老大，而与上面不同的是，此时有三台服务器选举了它，所以它成为了这次选举的leader。

（4）服务器4启动，根据前面的分析，理论上服务器4应该是服务器1、2、3、4中最大的，但是由于前面已经有半数以上的服务器选举了服务器3，所以它只能接收当小弟的命了。

（5）服务器5启动，同4一样当小弟。

### ⑨Znode

在谈到分布式的时候，我们通常说的“节点"是指组成集群的每一台机器。

然而，在 ZooKeeper 中，“节点"分为两类：

- 第一类同样是指构成集群的机器，**我们称之为机器节点。**
- 第二类则是指数据模型中的数据单元，**我们称之为数据节点一ZNode。**

ZooKeeper 将所有数据存储在内存中，数据模型是一棵树（Znode Tree)，由斜杠（/）的进行分割的路径，就是一个 Znode，例如/foo/path1。每个上都会保存自己的数据内容，同时还会保存一系列属性信息。

在 Zookeeper 中，Node 可以分为持久节点和临时节点两类。所谓持久节点是指一旦这个 ZNode 被创建了，除非主动进行 ZNode 的移除操作，否则这个 ZNode 将一直保存在 ZooKeeper 上。

而临时节点就不一样了，它的生命周期和客户端会话绑定，一旦客户端会话失效，那么这个客户端创建的所有临时节点都会被移除。

另外，ZooKeeper 还允许用户为每个节点添加一个特殊的属性：SEQUENTIAL。

一旦节点被标记上这个属性，那么在这个节点被创建的时候，ZooKeeper 会自动在其节点名后面追加上一个整型数字，这个整型数字是一个由父节点维护的自增数字。

### ⑩版本

在前面我们已经提到，Zookeeper 的每个 ZNode 上都会存储数据，对应于每个 ZNode，Zookeeper 都会为其维护一个叫作 Stat 的数据结构。

Stat 中记录了这个 ZNode 的三个数据版本，分别是：

- **version（当前 ZNode 的版本）**
- **cversion（当前 ZNode 子节点的版本）**
- **aversion（当前 ZNode 的 ACL 版本）**

## 4、Zookeeper 安装

![1.Zookeeper5](C:\Users\Administrator\Desktop\笔记\Zookeeper\1.Zookeeper5.png)





















































































